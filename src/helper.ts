import { exit } from 'node:process';
import { RumbleFrequencyLowerLimit, RumbleFrequencyUpperLimit } from './data';
import { debugInfo, debugMode } from './debug';
import { requestFlashMemory } from './event';
import { writeOutputReport } from './output_report';

/**
 * 16進表記に0xを付与する。
 * @param n 16進表記にする数
 * @param m 0-paddingする数
 * @returns 16進表記にした文字列
 */
export function toHex(n: number, m: number = 2): string {
  return '0x' + ("0".repeat(m) + n.toString(16)).slice(-1*m);
}

/**
 * DataViewをArrayに変換する。
 * @param data もととなるDataView
 * @param head 先頭index
 * @param len DataViewの変換する長さ
 * @returns DataViewの変換後のArray
 */
export function dataViewToArray(data: DataView, head: number = 0, len: number = data.byteLength): Array<number> {
  let arr:Array<number> = [];
  for(let i = head;i<Math.min(data.byteLength, len + head);i++){
    arr.push(data.getUint8(i));
  }
  return arr;
}

/**
 * High bandの周波数をエンコードする。
 * @param rawFreq 周波数
 * @returns エンコードされた周波数
 */
export function encodeHighFreq(rawFreq: number): number {
  rawFreq = Math.max(rawFreq, RumbleFrequencyLowerLimit);
  rawFreq = Math.min(rawFreq, RumbleFrequencyUpperLimit);

  return (Math.round(Math.log2(rawFreq / 10.0) * 32.0) - 0x60) * 4;
}

/**
 * Low bandの周波数をエンコードする。
 * @param rawFreq 周波数
 * @returns エンコードされた周波数
 */
export function encodeLowFreq(rawFreq: number): number {
  rawFreq = Math.max(rawFreq, RumbleFrequencyLowerLimit);
  rawFreq = Math.min(rawFreq, RumbleFrequencyUpperLimit);
  
  return Math.round(Math.log2(rawFreq / 10.0) * 32.0) - 0x40;
}

/**
 * High bandの振幅をエンコードする。
 * @param rawFreq 振幅
 * @returns エンコードされた振幅
 */
export function encodeHighAmpli(rawAmpli: number): number {
  let encodedAmpli = 0;

  if (0 < rawAmpli && rawAmpli < 0.012) {
    encodedAmpli = 1;
  } else if (0.012 <= rawAmpli && rawAmpli < 0.112) {
    encodedAmpli = Math.round(4 * Math.log2(rawAmpli * 110));
  } else if (0.112 <= rawAmpli && rawAmpli < 0.225) {
    encodedAmpli = Math.round(16 * Math.log2(rawAmpli * 17));
  } else if (0.225 <= rawAmpli && rawAmpli <= 1) {
    encodedAmpli = Math.round(32 * Math.log2(rawAmpli * 8.7));
  }

  return encodedAmpli * 2;
}

/**
 * Low bandの振幅をエンコードする。
 * @param rawFreq 振幅
 * @returns エンコードされた振幅
 */
export function encodeLowAmpli(rawAmpli: number): number {
  let encodedAmpli = 0;

  if (0 < rawAmpli && rawAmpli < 0.012) {
    encodedAmpli = 1;
  } else if (0.012 <= rawAmpli && rawAmpli < 0.112) {
    encodedAmpli = Math.round(4 * Math.log2(rawAmpli * 110));
  } else if (0.112 <= rawAmpli && rawAmpli < 0.225) {
    encodedAmpli = Math.round(16 * Math.log2(rawAmpli * 17));
  } else if (0.225 <= rawAmpli && rawAmpli <= 1) {
    encodedAmpli = Math.round(32 * Math.log2(rawAmpli * 8.7));
  }

  return Math.floor(encodedAmpli / 2) + 64;
}

/**
 * Output report用のpacket number管理クラス
 */
export class PacketManager{
  static packetNum = 0;

  static get(): number{
    return this.packetNum++;
  }
}

/**
 * Arrayを16進数の文字列に変換する
 * @param arr もととなるArray
 * @param str 間に挟む文字列
 * @returns 16進数の文字列
 */
export function arrayToHexString(arr: Array<number>, str: string = ","): string {
  return arr.map(x => x.toString(16).padStart(2,"0")).join(str);
}

const CRCTABLE8 = [
  0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,
  0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
  0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65,
  0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
  0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5,
  0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
  0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85,
  0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
  0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2,
  0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
  0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2,
  0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
  0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32,
  0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
  0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,
  0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
  0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C,
  0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
  0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC,
  0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
  0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C,
  0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
  0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C,
  0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
  0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B,
  0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
  0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B,
  0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
  0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB,
  0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
  0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB,
  0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3]

/**
 * CRC-8-CCITTの計算を行う。
 * @param data もととなるデータ
 * @returns 計算結果
 */
export function calcCrc8(data: Array<number>): number {
  let val = 0
  let pos = 0
  data.forEach(element => {
    val = CRCTABLE8[val ^ element]
  });
  return val
}

const CRCTABLE16 = [
  0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241,
	0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440,
	0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40,
	0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841,
	0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
	0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
	0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
	0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
	0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
	0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
	0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
	0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
	0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
	0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
	0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
	0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
	0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
	0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
	0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
	0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
	0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
	0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
	0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
	0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
	0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
	0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
	0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
	0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
	0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
	0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
	0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
	0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040]

/**
 * CRC-16-CCITTの計算を行う。
 * @param data もととなるデータ
 * @returns 計算結果
 */
export function calcCrc16(data: Array<number>): number {
  let val = 0
  let pos = 0
  data.forEach(element => {
    val = (val >> 8) ^ CRCTABLE16[(val ^ element) & 0x00ff]
  });
  return val
}

/**
 * 指定されたIDのModalの表示を行う。
 * @param id 対象ElementのID
 */
export function displayModal(id: string){
  $('#'+id).modal('show')
}

/**
 * Joy-Con内のフラッシュメモリのダンプの管理を行う。
 */
export class MemoryDumpManager {
  static requestedQueue: number[][] = [];
  static resendingCount = 0;
  static sending = false;

  /**
   * データの要求の記録を行う。
   * @param headAddr 要求データのヘッダアドレス
   * @param length 要求データの長さ
   * @returns データの要求が可能かどうか
   */
  static requestData(headAddr: number, length: number): boolean {
    if (length<=0 || length>0x1d || headAddr<0) {
      return false;
    }
    // enqueue
    this.requestedQueue.push([headAddr, length]);
    return true;
  }

  /**
   * 返信データの確認を行う。
   * ACK、NACKの確認、パケットロスであれば再送処理を行う。
   * @param data 返信データ
   * @returns 正規の返信データであるかどうか
   */
  static receiveData(data: DataView): boolean {
    console.log(arrayToHexString(dataViewToArray(data)));
    if (data.getUint8(12) === 0x90) {  //ACK
      if (this.requestedQueue[0][0] === data.getUint16(14,true) && this.requestedQueue[0][1] === data.getUint8(18)) {
        this.requestedQueue.splice(0,1);
        return true;
      }

      if (this.resendingCount>2) {
        debugInfo("Resending count is over.");
        this.resendingCount = 0;
        return false;
      }

      //再送処理
      requestFlashMemory(data.getUint16(14), data.getUint8(18));
      this.resendingCount++;
      console.log("resending");

      debugInfo("Recived data wasn't request.");
      return false;
    } else {  //NACK
      if (this.sending === false) { //送信処理を行っていないときのものはスルー
        return true;
      }
      return false;
    }
  }

  static startSendReport() {
    this.sending = true;
  }

  static stopSendReport() {
    this.sending = false;
  }

  static isSending(): boolean {
    return this.sending;
  }

  static isEmptyRequestedQueue(): boolean {
    if (this.requestedQueue.length === 0) {
      return true;
    }
    return false;
  }
}

export function arrayToAddress(arr: number[]): string {
  let retval: string[] = [];
  retval = arr.map(x => x.toString(16).padStart(2,"0"));
  return retval.join(":");
}

export function byteToInt16(arr: number[]): number {
  let retval = arr[0] * 0x100 + arr[1];
  if ((arr[0] & 0x80) === 0x80) {
    retval = -1 * (~(retval - 1) & 0xff);
  }

  return retval;
}